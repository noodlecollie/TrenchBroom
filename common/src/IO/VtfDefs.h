/*
 Copyright (C) 2010-2017 Kristian Duske

 This file is part of TrenchBroom.

 TrenchBroom is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 TrenchBroom is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with TrenchBroom. If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <cstdint>

#ifdef _MSC_VER
#define TB_IO_VTF_ALIGN16 __declspec(align(16))
#else
#define TB_IO_VTF_ALIGN16 __attribute__((aligned(16)))
#endif

namespace TrenchBroom {
namespace IO {
namespace Vtf {
// Much of this format info is borrowed from https://github.com/panzi/VTFLib
// Of course, the TrenchBroom formatting conventions mangle some of it.

enum ImageFormat {
  IMAGE_FORMAT_RGBA8888 = 0,      //  = Red, Green, Blue, Alpha - 32 bpp
  IMAGE_FORMAT_ABGR8888,          //  = Alpha, Blue, Green, Red - 32 bpp
  IMAGE_FORMAT_RGB888,            //  = Red, Green, Blue - 24 bpp
  IMAGE_FORMAT_BGR888,            //  = Blue, Green, Red - 24 bpp
  IMAGE_FORMAT_RGB565,            //  = Red, Green, Blue - 16 bpp
  IMAGE_FORMAT_I8,                //  = Luminance - 8 bpp
  IMAGE_FORMAT_IA88,              //  = Luminance, Alpha - 16 bpp
  IMAGE_FORMAT_P8,                //  = Paletted - 8 bpp
  IMAGE_FORMAT_A8,                //  = Alpha- 8 bpp
  IMAGE_FORMAT_RGB888_BLUESCREEN, //  = Red, Green, Blue, "BlueScreen" Alpha - 24 bpp
  IMAGE_FORMAT_BGR888_BLUESCREEN, //  = Red, Green, Blue, "BlueScreen" Alpha - 24 bpp
  IMAGE_FORMAT_ARGB8888,          //  = Alpha, Red, Green, Blue - 32 bpp
  IMAGE_FORMAT_BGRA8888,          //  = Blue, Green, Red, Alpha - 32 bpp
  IMAGE_FORMAT_DXT1,              //  = DXT1 compressed format - 4 bpp
  IMAGE_FORMAT_DXT3,              //  = DXT3 compressed format - 8 bpp
  IMAGE_FORMAT_DXT5,              //  = DXT5 compressed format - 8 bpp
  IMAGE_FORMAT_BGRX8888,          //  = Blue, Green, Red, Unused - 32 bpp
  IMAGE_FORMAT_BGR565,            //  = Blue, Green, Red - 16 bpp
  IMAGE_FORMAT_BGRX5551,          //  = Blue, Green, Red, Unused - 16 bpp
  IMAGE_FORMAT_BGRA4444,          //  = Red, Green, Blue, Alpha - 16 bpp
  IMAGE_FORMAT_DXT1_ONEBITALPHA,  //  = DXT1 compressed format with 1-bit alpha - 4 bpp
  IMAGE_FORMAT_BGRA5551,          //  = Blue, Green, Red, Alpha - 16 bpp
  IMAGE_FORMAT_UV88,              //  = 2 channel format for DuDv/Normal maps - 16 bpp
  IMAGE_FORMAT_UVWQ8888,          //  = 4 channel format for DuDv/Normal maps - 32 bpp
  IMAGE_FORMAT_RGBA16161616F,     //  = Red, Green, Blue, Alpha - 64 bpp
  IMAGE_FORMAT_RGBA16161616,      //  = Red, Green, Blue, Alpha signed with mantissa - 64 bpp
  IMAGE_FORMAT_UVLX8888,          //  = 4 channel format for DuDv/Normal maps - 32 bpp
  IMAGE_FORMAT_R32F,              //  = Luminance - 32 bpp
  IMAGE_FORMAT_RGB323232F,        //  = Red, Green, Blue - 96 bpp
  IMAGE_FORMAT_RGBA32323232F,     //  = Red, Green, Blue, Alpha - 128 bpp
  IMAGE_FORMAT_NV_DST16,
  IMAGE_FORMAT_NV_DST24,
  IMAGE_FORMAT_NV_INTZ,
  IMAGE_FORMAT_NV_RAWZ,
  IMAGE_FORMAT_ATI_DST16,
  IMAGE_FORMAT_ATI_DST24,
  IMAGE_FORMAT_NV_NULL,
  IMAGE_FORMAT_ATI2N,
  IMAGE_FORMAT_ATI1N,
  IMAGE_FORMAT_COUNT,
  IMAGE_FORMAT_NONE = -1
};

enum TextureFlags {
  TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
  TEXTUREFLAGS_TRILINEAR = 0x00000002,
  TEXTUREFLAGS_CLAMPS = 0x00000004,
  TEXTUREFLAGS_CLAMPT = 0x00000008,
  TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
  TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
  TEXTUREFLAGS_SRGB = 0x00000040, // Originally internal to VTex as TEXTUREFLAGS_NOCOMPRESS.
  TEXTUREFLAGS_DEPRECATED_NOCOMPRESS = 0x00000040,
  TEXTUREFLAGS_NORMAL = 0x00000080,
  TEXTUREFLAGS_NOMIP = 0x00000100,
  TEXTUREFLAGS_NOLOD = 0x00000200,
  TEXTUREFLAGS_MINMIP = 0x00000400,
  TEXTUREFLAGS_PROCEDURAL = 0x00000800,
  TEXTUREFLAGS_ONEBITALPHA = 0x00001000,   // Automatically generated by VTex.
  TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000, // Automatically generated by VTex.
  TEXTUREFLAGS_ENVMAP = 0x00004000,
  TEXTUREFLAGS_RENDERTARGET = 0x00008000,
  TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
  TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
  TEXTUREFLAGS_SINGLECOPY = 0x00040000,
  TEXTUREFLAGS_UNUSED0 =
    0x00080000, // Originally internal to VTex as TEXTUREFLAGS_ONEOVERMIPLEVELINALPHA.
  TEXTUREFLAGS_DEPRECATED_ONEOVERMIPLEVELINALPHA = 0x00080000,
  TEXTUREFLAGS_UNUSED1 =
    0x00100000, // Originally internal to VTex as TEXTUREFLAGS_PREMULTCOLORBYONEOVERMIPLEVEL.
  TEXTUREFLAGS_DEPRECATED_PREMULTCOLORBYONEOVERMIPLEVEL = 0x00100000,
  TEXTUREFLAGS_UNUSED2 = 0x00200000, // Originally internal to VTex as TEXTUREFLAGS_NORMALTODUDV.
  TEXTUREFLAGS_DEPRECATED_NORMALTODUDV = 0x00200000,
  TEXTUREFLAGS_UNUSED3 =
    0x00400000, // Originally internal to VTex as TEXTUREFLAGS_ALPHATESTMIPGENERATION.
  TEXTUREFLAGS_DEPRECATED_ALPHATESTMIPGENERATION = 0x00400000,
  TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,
  TEXTUREFLAGS_UNUSED4 = 0x01000000, // Originally internal to VTex as TEXTUREFLAGS_NICEFILTERED.
  TEXTUREFLAGS_DEPRECATED_NICEFILTERED = 0x01000000,
  TEXTUREFLAGS_CLAMPU = 0x02000000,
  TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,
  TEXTUREFLAGS_SSBUMP = 0x08000000,
  TEXTUREFLAGS_UNUSED5 = 0x10000000, // Originally TEXTUREFLAGS_UNFILTERABLE_OK.
  TEXTUREFLAGS_DEPRECATED_UNFILTERABLE_OK = 0x10000000,
  TEXTUREFLAGS_BORDER = 0x20000000,
  TEXTUREFLAGS_DEPRECATED_SPECVAR_RED = 0x40000000,
  TEXTUREFLAGS_DEPRECATED_SPECVAR_ALPHA = 0x80000000,
  TEXTUREFLAGS_LAST = 0x20000000,
  TEXTUREFLAGS_COUNT = 30
};

static constexpr uint32_t RESOURCETYPE_IMAGE = 0x30;

struct ImageFormatInfo {
  ImageFormat formatValue;
  const char* name;         // Enumeration text equivalent.
  size_t bitsPerPixel;      // Format bits per pixel.
  size_t bytesPerPixel;     // Format bytes per pixel.
  size_t redBitsPerPixel;   // Format red bits per pixel.  0 for N/A.
  size_t greenBitsPerPixel; // Format green bits per pixel.  0 for N/A.
  size_t blueBitsPerPixel;  // Format blue bits per pixel.  0 for N/A.
  size_t alphaBitsPerPixel; // Format alpha bits per pixel.  0 for N/A.
  bool isCompressed;        // Format is compressed (DXT).
};

static constexpr char FILE_SIGNATURE[4] = {'V', 'T', 'F', '\0'};

#pragma pack(push, 1)

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4324) // Warnings about the alignment we explicitly set
#endif // _MSC_VER

struct HeaderBase {
  char typeString[4];  // "Magic number" identifier- "VTF\0".
  uint32_t version[2]; // Version[0].version[1]
  uint32_t headerSize; // Size of the header struct (currently 80 bytes)
};

struct Header_70 : public HeaderBase {
  uint16_t width;             // Width of the largest image
  uint16_t height;            // Height of the largest image
  uint32_t flags;             // Flags for the image
  uint16_t frames;            // Number of frames if animated (1 for no animation)
  uint16_t startFrame;        // Start frame (always 0)
  uint8_t padding0[4];        // Reflectivity padding (16 byte alignment)
  float reflectivity[3];      // Reflectivity vector
  uint8_t padding1[4];        // Reflectivity padding (8 byte packing)
  float bumpScale;            // Bump map scale
  int32_t imageFormat;        // Image format index
  uint8_t mipCount;           // Number of MIP levels (including the largest image)
  int32_t lowResImageFormat;  // Image format of the thumbnail image
  uint8_t lowResImageWidth;   // Thumbnail image width
  uint8_t lowResImageHeight;  // Thumbnail image height
};

struct TB_IO_VTF_ALIGN16 Header_70_A : public Header_70 {};

struct Header_72 : public Header_70 {
  uint16_t depth; // Depth of the largest image
};

struct TB_IO_VTF_ALIGN16 Header_72_A : public Header_72 {};

struct Header_73 : public Header_72 {
  uint8_t padding2[3];
  uint32_t resourceCount; // Number of image resources
};

struct TB_IO_VTF_ALIGN16 Header_73_A : public Header_73 {};

struct Resource {
  union {
    uint32_t type;
    struct {
      uint8_t id[3]; // Unique resource ID
      uint8_t flags; // Resource flags
    } s;             // ISO C++ requires struct name
  };
  uint32_t data; // Resource data (e.g. for a  CRC) or offset from start of the file
};

struct ResourceData {
  uint32_t size; // Resource data buffer size
  uint8_t* data; // Resource data bufffer
};

struct TextureLODControlResource {
  uint8_t resolutionClampU;
  uint8_t resolutionClampV;
  uint8_t padding[2];
};

struct TextureSettingsExResource {
  uint8_t flags0;
  uint8_t flags1;
  uint8_t flags2;
  uint8_t flags3;
};

#ifdef _MSC_VER
#pragma warning(pop)
#endif // _MSC_VER

#pragma pack(pop)

const ImageFormatInfo* getImageFormatInfo(ImageFormat imageFormat);

} // namespace Vtf
} // namespace IO
} // namespace TrenchBroom
